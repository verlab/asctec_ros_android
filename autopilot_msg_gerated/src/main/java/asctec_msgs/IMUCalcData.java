package asctec_msgs;

public interface IMUCalcData extends org.ros.internal.message.Message {
  static final java.lang.String _TYPE = "asctec_msgs/IMUCalcData";
  static final java.lang.String _DEFINITION = "# Software License Agreement (BSD License)\n#\n# Copyright (c) 2010\n#  William Morris <morris@ee.ccny.cuny.edu>\n#  Ivan Dryanovski <ivan.dryanovski@gmail.com>\n# All rights reserved.\n#\n# Redistribution and use in source and binary forms, with or without\n# modification, are permitted provided that the following conditions\n# are met:\n#\n#  * Redistributions of source code must retain the above copyright\n#    notice, this list of conditions and the following disclaimer.\n#  * Redistributions in binary form must reproduce the above\n#    copyright notice, this list of conditions and the following\n#    disclaimer in the documentation and/or other materials provided\n#    with the distribution.\n#  * Neither the name of CCNY Robotics Lab nor the names of its\n#    contributors may be used to endorse or promote products derived\n#    from this software without specific prior written permission.\n#\n# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n# \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n# FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n# COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n# BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\n# LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER\n# CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT\n# LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN\n# ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n# POSSIBILITY OF SUCH DAMAGE.\n\nHeader header\n# angles derived by integration of gyro_outputs, drift compensated by data fusion;\n#-90000..+90000 pitch(nick) and roll, 0..360000 yaw; 1000 = 1 degree\n\nint32 angle_nick\nint32 angle_roll\nint32 angle_yaw\n\n# angular velocities, raw values [16 bit], bias free, in 0.0154 degree/s (=> 64.8 = 1 degree/s)\n\nint32 angvel_nick\nint32 angvel_roll\nint32 angvel_yaw\n\n# acc-sensor outputs, calibrated: -10000..+10000 = -1g..+1g\n\nint16 acc_x_calib\nint16 acc_y_calib\nint16 acc_z_calib\n\n# horizontal / vertical accelerations: -10000..+10000 = -1g..+1g\n\nint16 acc_x\nint16 acc_y\nint16 acc_z\n\n# reference angles derived by accelerations only: -90000..+90000; 1000 = 1 degree\n\nint32 acc_angle_nick\nint32 acc_angle_roll\n\n# total acceleration measured (10000 = 1g)\n\nint32 acc_absolute_value\n\n# magnetic field sensors output, offset free and scaled; units not determined, \n# as only the direction of the field vector is taken into account\n\nint32 Hx\nint32 Hy\nint32 Hz\n\n# compass reading: angle reference for angle_yaw: 0..360000; 1000 = 1 degree\n\nint32 mag_heading\n\n# pseudo speed measurements: integrated accelerations, pulled towards zero; units unknown;\n# used for short-term position stabilization\n\nint32 speed_x\nint32 speed_y\nint32 speed_z\n\n# height in mm (after data fusion)\n\nint32 height\n\n# diff. height in mm/s (after data fusion)\n\nint32 dheight\n\n# diff. height measured by the pressure sensor [mm/s]\n\nint32 dheight_reference\n\n# height measured by the pressure sensor [mm]\n\nint32 height_reference\n\n";
  std_msgs.Header getHeader();
  void setHeader(std_msgs.Header value);
  int getAngleNick();
  void setAngleNick(int value);
  int getAngleRoll();
  void setAngleRoll(int value);
  int getAngleYaw();
  void setAngleYaw(int value);
  int getAngvelNick();
  void setAngvelNick(int value);
  int getAngvelRoll();
  void setAngvelRoll(int value);
  int getAngvelYaw();
  void setAngvelYaw(int value);
  short getAccXCalib();
  void setAccXCalib(short value);
  short getAccYCalib();
  void setAccYCalib(short value);
  short getAccZCalib();
  void setAccZCalib(short value);
  short getAccX();
  void setAccX(short value);
  short getAccY();
  void setAccY(short value);
  short getAccZ();
  void setAccZ(short value);
  int getAccAngleNick();
  void setAccAngleNick(int value);
  int getAccAngleRoll();
  void setAccAngleRoll(int value);
  int getAccAbsoluteValue();
  void setAccAbsoluteValue(int value);
  int getHx();
  void setHx(int value);
  int getHy();
  void setHy(int value);
  int getHz();
  void setHz(int value);
  int getMagHeading();
  void setMagHeading(int value);
  int getSpeedX();
  void setSpeedX(int value);
  int getSpeedY();
  void setSpeedY(int value);
  int getSpeedZ();
  void setSpeedZ(int value);
  int getHeight();
  void setHeight(int value);
  int getDheight();
  void setDheight(int value);
  int getDheightReference();
  void setDheightReference(int value);
  int getHeightReference();
  void setHeightReference(int value);
}
